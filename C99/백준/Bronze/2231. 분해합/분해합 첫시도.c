//그니까 198에서 216이 되는건 198+1+9+8이라서 216인건 알겠음.
//분해합 N, 생성자 M
//N이 1~9일때 분해합의 범위 1~9
//N이 10~99일때 분해합의 범위 1~19
//N이 100~999일때 분해합의 범위 1~27
//N이 1,000~9,999일때 분해합의 범위 1~36
//N이 10,000~99,999일때 분해합의 범위 1~45
//N이 100,000~999,999일때 분해합의 범위 1~54
//N이 1,000,000일때 분해합은 1

//생성자가 없는경우?? ->
#include <stdio.h>
#include <string.h>

int main() {
    int N;                  // N=216
    scanf("%d", &N);
    int sum = 0;
    int digit = 0;  
    int m;
    int value;
    
    m = N;
    
    while(m!=0) {           //자릿수 판단
        m = m / 10;
        digit++;
        }

    if(N >= 1 && N <= 9) {          //한자리수
        printf("0 ");
    }
    
    if(N >= 10 && N <= 999999) {   //core logic
        for(int i=0; i<54; i++) {
            value = N - i;     //value = 198 (216-18) (N-i)
            int arr = value;
            for(int j=0; j<digit; j++) {        //각 요소 더하는 알고리즘 ex)1+9+8
                int cnt = 10;
                arr = arr + value%10;  
                value = value/10;
                cnt = 10*cnt;
                if(N == (value-1)+arr) {
                    printf("this is!!!%d", arr)
                }
                printf("arr : %d value : %d\n", arr, value);
            }
        }
        printf("last %d", value);
    }
    
    if(N == 1000000) printf("1");   //백만
}

//입력에서 출력을 뺀값 <-> 의 요소를 배열에 순서대로 저장. 이후 
/* 분해합 198 +18임
각 배열에 1~9만 배치가능.

ex) (<-> : 비교)
입력 : 216 
출력 : 198 (198+1+9+8) 1+9+8이 sum
1~27뺀값(198) <->
(뺄때 198을 string으로 저장하고 1, 9, 8을 각 배열에 저장함. 각 요소를 더하고(이때 아스키코드 연산 사용)
그 값을 198에 더했을때 입력값과 같으면 출력.)


입력 : 486
출력 : 468 (468+18)
1~27 뺀값(468) <->
(뺄때 468을 string으로 저장하고 4,6,8을 각 배열에 저장함. 각요소를 더하고(이때 아스키코드 연산 사용)
그 값을 468에 더했을때 입력값과 같으면 출력.)


입: 1002
출: 978 (978+24)
1~36 뺀값(1002)
(뺄때 978를 문자열로 저장. 9,7,8을 각 배열에 저장. 각 요소를 더함.(아스키)
그 값을 978에 더했을때 입력값과 같으면 출력)

입: 520
출: 512 (512+8)


*/
